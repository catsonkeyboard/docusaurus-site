---
sidebar_position: 1
---
### Java基础
1. 谈谈对static的理解，什么时候定义static方法
- 在java中，static关键字用于表示类级别的成员（变量或方法），而不是实例级的成员。这意味着static成员属于类本身，而不是类的某个特定实例。
	- 类变量
	- 静态方法，静态方法属性类本身，因此可以在没有创建类实例的情况下调用，静态方法只能访问其他静态成员，不能访问实例成员
	- 静态方法不能被override，也不能声明为final和abstract，不能作为构造函数
	- 内存管理，静态成员在类加载到JVM就会创建，并在类卸载时销毁。由于静态成员不属于任何实例，因此它们占用的内存比实例成员少
- 使用场景：
	- 当方法不需要访问类的实例变量或者实例方法时，可以声明为static
	- 如工具类、
	- 当需要创建单例类，可以将构造函数声明为private static，确保只能创建一个实例
	- 当需要创建全局变量或者方法时，可以使用static变量或者方法
2. final修饰方法、类各自是什么意思
- final类：不能被继承
- final方法：不能被子类重写（override），保护方法的实现不能被更改
- 
### Java 底层技术
1. ArrayList底层原理、扩容原理
- 底层是一个动态数组的实现，这个数组存储了所有元素，可以快速随机访问
- 动态扩容：`ArrayList`的容量会随着元素的添加而动态增长。当数组的容量不足以添加新元素时，`ArrayList`会创建一个新的数组，并将旧数组中的元素复制到新数组中。新数组的容量通常是旧容量的1.5倍再加1，这是为了避免频繁的扩容操作。
- 性能考虑：由于`ArrayList`是基于数组实现的，所以在添加和删除元素时可能需要进行数组的扩容和元素的移动，这会影响性能。因此，在元素数量相对稳定的情况下，`ArrayList`的性能较好。如果需要频繁地添加或删除元素，可能需要考虑其他数据结构，如`LinkedList`。
1. LinkedList底层原理、和ArrayList区别
- 底层是双向链表的实现
- 头节点指向上一个节点的尾节点，中间节点指向该节点，尾节点指向下一个节点的头节点
- 需要频繁读取集中的元素时，更推荐使用ArrayList，而在增删改操作比较多的时候，更加推荐使用LinkedList
1. HashMap的底层原理、扩容原理
- 数组+链表+红黑树
- HashMap的底层采用了一个数组，该数组的默认大小为16且每一个元素都是一个链表的头节点
- 当容量达到负载因子*元素数量时，进行扩容一倍
- 性能考虑：扩容是一个昂贵的操作，因为它涉及到重新计算所有元素的哈希值和可能的内存分配。为了减少扩容操作的频率，可以在创建`HashMap`时通过构造方法的参数设置一个较大的初始容量。这样可以减少在`HashMap`生命周期中的扩容次数，从而提高性能
1. ConcurrentHashMap的原理
- 底层采用分段的数组+链表+红黑树实现，线程安全
- Java8之后使用Node锁

### JVM
1. JVM中，栈（Stack）和堆（Heap）是两种非常重要的内存区域，栈用于存储局部变量和方法调用上下文信息，堆是JVM中最大的内存区域，用于存储对象实例和数组，与栈不同，堆是所有线程共享的内存空间
2. 程序计数器、虚拟机栈、本地方法栈、堆（运行时数据区）、方法区/永久代
3. 这几个哪些会发生内存溢出，栈内存什么时候会溢出
- 都会发生内存溢出
- 栈内存溢出，StackOverflow，递归调用过深，局部变量过多
- 堆内存溢出，OutOfMemory，内存泄漏、大量对象创建、不合理JVM参数
- 方法区内存溢出，类定义过多、元数据膨胀
1. 垃圾回收机制怎么识别垃圾
	- 引用计数法：对每个对象进行引用计数，每当有对象引用时计数器+1，引用失效-1，小于0则意味对象可以回收
	- 可达性分析法：从被称为GC Root的节点为起点，这些被引用的节点形成引用链，可被搜索到的对象视为可达对象，如果该对象到GC Root没有任何引用链相连的话，此对象在后续将会被回收。
2. 可作为GC Root的对象：
	- 虚拟机栈（栈帧中的本地变量表）中引用的对象
	- 本地方法栈（Native方法）中引用的对象
	- 方法区中类静态属性引用的对象
	- 方法区中常量引用的对象
	- 所有被同步锁持有的对象
3. G1（Garbage-First）收集器：
	- 面向服务器的收集器，适用于多核处理器和大内存环境
	- 基于分代收集和局部的标记-复制算法，同时进行全局的标记-整理
	- 目标是提供可预测的停顿时间，同时保持高吞吐量
	- 从JDK9开始成为默认的垃圾回收器
4. JVM垃圾回收流程：
	- 对象创建：应用程序在堆（Heap）内存中创建对象，分配在新生代Eden区
	- Minor GC：当Eden区满，触发Minor GC（Young GC），这是新生代的垃圾回收过程。在Minor GC期间，Eden区和Survivor区中存活的对象会被移动到另一个survivor区，并且每个存活对象的年龄增加，不存活的对象会被回收
	- 对象晋升，经过多次Minor GC后仍然存活的对象会被晋升到老年代
	- Major GC/Full GC：当老年代空间不足会触发Major GC或Full GC，这是整个堆的垃圾回收过程，包括新生代和老年代，这个过程通常比Minor GC耗时更长，并可能导致更长时间的停顿
	- 垃圾判断：垃圾回收期需要判断哪些对象是垃圾，通常通过可达性分析来实现，从GC Root开始，通过引用链判断对象是否可达
	- 垃圾回收算法：根据选定的垃圾回收器和堆内存的结构，垃圾回收器会采用不同的算法来回收垃圾，如标记-清除、标记-复制、标记-整理
	- 内存整理：在某些垃圾回收算法中，如标记-整理，可能需要在回收垃圾后对内存进行整理，以消除内存碎片，优化内存使用
	- 并发处理：一些现代的垃圾回收器（G1、ZGC、Shenandoah）会在垃圾回收过程中并发执行一些步骤，以减少对应用线程的影响。
	- 回收完成：垃圾回收完成后，回收的内存会被标记为可用，可以分配给新创建的对象。
	- 反馈循环：JVM会根据垃圾回收的历史数据和当前内存的使用情况，调整垃圾回收策略和参数，以优化未来的垃圾回收过程

### 线程

1. 如何启动一个线程
 - 通过Thread类的Start方法
 - 实现Runable接口，实现run方法
 2. 如何阻塞一个线程
 - wait()方法
 3. wait()使用有什么限制
 - 必须在同步上下文中调用：wait()方法必须在同步块或同步方法中调用，意味wait()的线程必须持有当前对象的锁
 - 释放锁：当线程调用wait()，它会释放当前对象的锁，使其他线程可以获取该对象的锁并进入同步块或者同步方法，避免死锁产生
 - 等待时间：可以接受等待时间，如果指定了等待时间，线程会在指定时间内等待，如果没有等待时间，则线程会无限期等待，直到notify()方法唤醒
 - 响应中断：线程在wait()状态被中断，它会抛出InterruptedException，需要捕获异常进行适当处理
 - 唤醒条件：线程在wait()状态时，只有当其他线程调用了当前对象的notify()或者notifyAll()方法时才能唤醒
 - 返回值：wait()方法在正常返回时返回0，超时返回-1，如果中断抛出InterruptedException
 - 与其他线程交互：当线程使用wait()方法等待时，它无法进行其他操作，包括与其他线程的交互，因此，必须确保在适当的时机使用notify进行唤醒，避免无限期等待和死锁
 4. 有返回值的线程，实现Callable接口，使用threadPool.submit()执行任务获取Feature对象，feature.get()获取执行结果
 5. 线程池：
 - 四种线程池， ExcutorService pool = Executor.newFixedTheadPool(size);
 - newCachedThreadPool：创建一个可以根据需要创建新线程的线程池
 - newFixedThreadPool：创建一个可重用固定线程数的线程池
 - newScheduledThreadPool：创建一个线程池，它可安排在给定延迟后运行命令或者定期执行
 - newSingleThreadExecutor：返回一个线程池（这个线程池只有一个线程），这个线程池可以在线程死后或者发生异常时，重新启动一个线程替代原来的线程继续执行下去
 6. 线程的生命周期：
 - 新建（创建后）、就绪（调用start()方法后）、运行（就绪状态的线程获得了CPU，开始执行run()方法）、阻塞、死亡（正常结束、异常结束、调用stop）
 - 阻塞：
	 - 等待阻塞，运行中的线程执行wait()方法，JVM会把该线程放入等待队列中
	 - 同步阻塞，运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，JVM会把该线程放入锁池中
	 - 其他阻塞，运行的线程执行Thread.sleep或join方法时，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep状态超时，join等待线程终止或者超时，或者I/O处理完毕，线程重新转入可运行状态
![[Pasted image 20240402095803.png]]

### JAVA锁


### Spring 原理
1. Spring IOC的理解，怎么理解控制反转，IOC中的Bean的生命周期
	- IOC是Spring的核心，IOC意味着将你设计好的对象交给容器控制，而不是传统的在对象内部直接控制
	- 控制反转：所有的类都会在Spring容器中登记，告诉Spring你是什么，你需要什么，然后Spring会在系统运行到适当的时候，把你想要的东西主动给你，同时也把你交给其他需要你的东西，所有的类的创建、销毁都由Spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是Spring对于某个具体对象而言，以前是它控制其他对象，现在是所有对象都被Spring控制，所以这叫控制反转
	- 是一种设计原则，用于减少代码之间的耦合，在传统的程序设计中，组件之间的依赖关系通常是由组件自身在内部创建或查找其依赖项。而在采用控制反转的设计原则后，这种依赖关系的创建和查找工作由外部容器（如Spring容器）来完成，组件本身不需要关心如何获得其依赖项
2. Spring如何解决IOC中的循环依赖关系：
	- 三级缓存：一级缓存存放就绪状态的Bean用完释放。。。
3. SpringMVC（SpringBoot）流程，DispatcherServlet->HandlerMapping->HandlerAdapter->Controller->Response
- 用户发送请求至前端控制器（DispatcherServlet）
- 前端控制器DispatcherServlet收到请求调用HandlerMapping处理器映射器
- 处理器映射器找到具体的处理器（xml、注解进行查找），生成处理器对象及处理器拦截器，一并返回给DispatcherServlet
- DispatcherServlet调用HandlerAdapter处理器适配器
- HandlerAdapter经过适配调用具体的处理器（Controller，也叫后端控制器）
- 后端控制器中实现具体的业务，处理器方法中返回一个对象（通常是DTO或者Model对象），SpringBoot默认配置自动将对象转换为JSON或XML响应，如果是视图，会使用ViewResolver来找到对应的视图模板
- 根据处理器方法返回值，SpringBoot会构建HTTP响应，发送给客户端
4. Spring AOP理解，有哪些通知，使用场景
- 面向切面编程，将业务无关、却为业务模块所共同调用的逻辑封装起来，便于减少系统的重复代码，降低模块的耦合度，并有利于可操作性和可维护性
- 通知有：前置通知、环绕通知、后置通知、异常通知、最终通知
- 使用场景有：日志、事务、缓存
5. 什么情况下会让Spring的事务失效
- 发生自调用
- 方法不是public的
- 数据库不支持事务
- 没有被Spring管理
- 异常被try catch，事务不会回滚
6. Spring的核心注解，分别有什么作用
- @Controller web控制器
- @Service 服务模式注解
- @Component 通用组件模式注解
- @Autowired Bean依赖注入，支持多种依赖查找方式
- @Bean 替换XML元素\<Bean /\>
- @Import 限定@Autowired依赖注入范围（导入对应的@Configuration标识类）
- @ComponentScan 扫描指定package下标注Spring模式注解的类
7. SpringBoot的自动装配原理
- @EnableAutoConfiguration这个注解通过@SpringBootApplication这个注解被间接标记在了SpringBoot项目的启动类上，在SpringApplication.run()的内部就会执行selectimports()方法，找到所有javaconfig自动配置类的全限定类名对应的class，然后将所有的自动配置类加载到Spring容器中
8. SpringBoot的核心注解及作用
- @SpringBootConfiguration 配置类
- @EnableAutoConfiguration 自动配置包，
- @ComponentScan 默认会扫描该类所在包下的所有配置类
9. SpringBoot项目的启动流程：初始化、自动配置、组件扫描、创建应用程序上下文、启动内嵌Web服务器等
- 初始化：执行一些基础的初始化工作，包括加载配置文件、初始化环境、设置日志系统等
- 启动类：主类上使用注解@SpringBootApplication，是个组合注解，包含@Configuration、@EnableAutoConfiguration、@ComponentScan，告诉应用程序应该扫描组件、启用自动配置，并启动应用程序
- 运行时配置：Spring Boot根据类路径上的jar依赖和存在的配置文件来自动配置应用程序。这个过程中，Spring Boot会根据`spring.factories`文件中指定的自动配置类来创建Bean定义，并注册到Spring应用程序上下文中
- 组件扫描：`@ComponentScan`注解告诉Spring Boot扫描指定包路径下的所有组件（如`@Component`、`@Service`、`@Controller`等），并将它们注册为Spring容器中的Bean
- 创建应用程序上下文：Spring Boot会创建一个应用程序上下文（`ApplicationContext`），通常是`AnnotationConfigServletWebServerApplicationContext`或`SpringBootServletInitializer`的实例。这个上下文负责管理应用程序中的所有Bean，并处理HTTP请求
- 初始化SpringBoot应用程序：Spring Boot应用程序初始化过程中，会执行所有的`@PostConstruct`和`@EventListener`注解的方法，以及`ApplicationRunner`和`CommandLineRunner`接口的实现类的`run`方法
- 启动内嵌Web服务：如果应用程序是一个Web应用程序，Spring Boot会自动配置并启动内嵌的Web服务器（如Tomcat、Jetty或Undertow）。这通常是由`TomcatServletWebServerFactory`、`JettyServletWebServerFactory`或`UndertowServletWebServerFactory`等类完成的。
- 应用程序运行：一旦内嵌Web服务器启动，Spring Boot应用程序就准备好接收HTTP请求了。此时，用户可以通过浏览器或其他HTTP客户端访问应用程序提供的端点。
1. 如何自定义SpringBoot Starter
- 引入SpringBoot自动化配置依赖 spring-boot-autoconfigure
- 创建配置属性类
- 创建starter包服务类
- 创建自动配置类（加上@Configuration）
- 配置spring.factories，需要自动配置类的全限定类名

### MYSQL 数据库
1. 索引是什么，索引的数据结构有哪些
- 索引是帮助数据库高效获取数据的数据结构，分为BTree索引和Hash索引
- Hash索引是一种检索效率非常高的定位索引，用于=，in，\<\>，不能用于范围查询
- Hash索引遇到大量Hash值相等的情况下检索效率不一定比BTee高
- 
2. 索引建立的原则
- 选择唯一性索引
- 为经常需要排序、分组和联合操作的字段建立索引
- 为常作为查询条件的字段建立索引
- 限制索引的数目
- 如果索引的值很长，那么查询效率会受到影响
- 删除不再使用，或者很少用的索引
- 最左前缀匹配原则
- 尽量选择区分度高的列作为索引（字段不重复的比例）
- 索引列不参与计算，尽量保持列的“干净”，带函数的查询不参与索引
- 尽量的扩展索引，不要新建索引
- 索引值最好NOT NULL
3. 索引的类型有哪些
- 普通索引、唯一索引、主键索引、复合索引、全文索引
4. 聚簇索引和非聚簇索引，主键是聚簇索引，每个表只有一个聚簇索引，聚簇索引决定表中数据的物理存储数据 ，聚簇索引查询快更新开销大
5. 如何进行mysql的优化
   sql层面：
- 避免使用select *
- 规范sql大小写，sql是有缓存的，避免每次解析
- 使用exists代替in
- mysql的解析执行过程是从右到左，from后面能过滤更多数据的基础表放最后，where后面能过滤更多数据的查询条件放在最后
- 查询条件中使用相同的数据类型去查询，避免数字列用字符串查询
- 合理使用索引
- expain命令进行sql慢查询排查
  服务器层面：
- 读写分离，主节点写，从节点读
- 分区，可以将数据按照业务时段分区，如月
- 分库、分表，涉及到中间件，如mycat
- 水平分表：字段都一样，多张表存放不同时段、不同维度的数据，垂直分表：将不同字段放在多张表，外键关联
6. mysql事务隔离级别
- 读未提交，指一个事务还没提交时，它做的变更就能被其他事务看到
- 读已提交，指一个事务提交之后，它做的变更才能被其他事务看到
- 可重复读，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**
- 串行化，会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行
- 可重复读和不可重复读区别：**不可重复读在一个事务内，两次读取同一行记录可能不一样，可重复读是同一个事务内，两次读取同一个范围内的数据记录数可能不一样**

### Redis
1. Redis缓存一致性：**因为缓存的写入通常要远远快于数据库的写入「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的**
2. Redis:内存数据结构存储，用作缓存、消息队列、分布式锁
3. Redis的数据类型：String，Hash，List，Set，ZSet
4. Redis的特性：具备高性能、高并发
5. Redis的线程模型：单线程、I/O多路复用机制
6. Redis的持久化：Redis的读写都在内存完成的，重启后会从磁盘恢复原有的数据，持久化方式：AOF日志、RDB快照、混合持久化方式
7. Redis集群如何实现服务高可用？
8. Redis的过期删除策略
9. 使用redis做分布式锁：
- 使用setnx()和expire()：setnx(lockkey,1)如果返回0占位失败，如果返回1，占位成功，expire()对lockkey设置超时时间，避免死锁，业务执行完通过delete删除key
- 基于sexnx()、get()、getset()方法做分布式锁
### Rabbitmq
1. Rabbitmq消息模式有哪些？
- direct 按照routing key发送、接受消息
- fanout 生产端发送消息，多个消费者接收所有消息
- topic 按照通配符匹配发送、接收消息
2. 如何保证MQ消息的可靠性：
- 开启生产者消息确认机制：ConfirmCallBack，ReturnCallBack
- 消息持久化
- 开启消费者确认机制
- 消费者重试机制
3. Rabbitmq如何实现延时消息：
- 利用死信交换机实现延时投递
- 利用延时交换机插件
4. Rabbitmq如何解决消息堆积问题
- 针对同一队列增加多个消费者
- 针对同一个消费者开启多个线程进行消费
- 加大队列的存储容量，设置一个队列为惰性队列，x-queue-mode=lazy，直接将消息写入到磁盘
5. 如何保证消息的幂等性
- 数据要写mysql，先根据主键查询一下，如果有数据就不插入，update
- 如果是redis，每次都set，天然幂等
- 让生产者发送每条数据的时候，里面加一个全局唯一的id

### K8S 微服务
1. 什么是微服务：微服务（Microservices）是一种软件架构风格，它将应用程序构建为一组小型、松散耦合的服务。每个服务都围绕特定的业务功能构建，运行在自己的进程中，并通过轻量级的通信机制（通常是HTTP RESTful API）进行交互。这种架构允许每个服务独立开发、部署和扩展，从而提高了系统的灵活性、可维护性和可伸缩性。
2. 微服务的特点：
	- 单一职责：每个服务负责一个特定的业务功能或一组紧密相关的功能
	- 独立性：服务可以独立于其他服务部署、扩展和更新
	- 分布式开发：团队可以独立地开发和测试他们的服务，使用他们选择的最佳技术栈
	- 弹性和容错性：服务的失败不会影响整个系统，可以单独重启失败的服务，而不会影响其他服务
	- 可伸缩性：可以根据需要对单个服务进行扩展，而不是整个应用程序
3. k8s组件有哪些，作用分别是什么
- master节点和node节点
- master节点负责管理集群，node节点是容器应用真正运行的地方
- master节点包含kube-api-server、kube-controller-manager、kube-scheduler、etcd
- node节点包含kubelet、kube-proxy、container-runtime